{"version":3,"sources":["noise/perlin_noise_2d.js"],"names":["GRID","GRID_MASK","SPEED","template","Array","from","length","_","k","x","y","l","Math","sqrt","normalizedVector","random","perlinNoise2D","w","h","t","Uint8ClampedArray","xNoise","yNoise","x0","y0","c00","c01","c10","c11","tx","ty","u","smoothstep","v","p01","p10","p11","nx0","lerp","dot","nx1","perlin","floor","a","b","cos","PI","a0","a1"],"mappings":"wJAAMA,EAAO,IACPC,EAAYD,EAAO,EACnBE,EAAQ,CAAC,EAAG,GAEZC,EAAWC,MAAMC,KAAK,CAACC,OAAQN,EAAOA,IAAO,SAACO,EAAGC,GAGrD,OAGF,YAAmC,IAAD,mBAAPC,EAAO,KAAJC,EAAI,KAC1BC,EAAIC,KAAKC,KAAKJ,EAAIA,EAAIC,EAAIA,GAChC,MAAO,CACLD,EAAIE,EACJD,EAAIC,GAPCG,CAAiB,CAFE,EAAhBF,KAAKG,SAAe,EACJ,EAAhBH,KAAKG,SAAe,OAYjB,SAASC,EAAcC,EAAGC,EAAGC,EAAGR,GAC7C,OAAOS,kBAAkBf,KAAK,CAACC,OAAQW,EAAIC,IAAI,SAACX,EAAGC,GAGjD,OAIJ,SAAgBa,EAAQC,EAAQL,EAAGC,GACjC,IAAMK,EAAKF,EAASpB,EACduB,EAAKF,EAASrB,EAEdwB,EAAMtB,EAASoB,EAAKC,EAAKxB,GACzB0B,EAAMvB,EAASoB,GAAMC,EAAK,GAAKxB,GAC/B2B,EAAMxB,EAASoB,EAAK,EAAIC,EAAKxB,GAC7B4B,EAAMzB,EAASoB,EAAK,GAAKC,EAAK,GAAKxB,GAEnC6B,EAAKR,EAASE,EACdO,EAAKR,EAASE,EACdO,EAAIC,EAAWH,GACfI,EAAID,EAAWF,GAGfI,EAAM,CAACL,EAAIC,EAAK,GAChBK,EAAM,CAACN,EAAK,EAAGC,GACfM,EAAM,CAACP,EAAK,EAAGC,EAAK,GAEpBO,EAAMC,EAAKC,EAAId,EALT,CAACI,EAAIC,IAKeS,EAAIZ,EAAKQ,GAAMJ,GACzCS,EAAMF,EAAKC,EAAIb,EAAKQ,GAAMK,EAAIX,EAAKQ,GAAML,GAG/C,OAAuB,KADTO,EAAKD,EAAKG,EAAKP,GACb,IA3BPQ,EAFKjC,EAAIS,EAAIE,EAAIjB,EAAM,IAAMS,EAAKX,GAC7BY,KAAK8B,MAAMlC,EAAIS,GAAKE,EAAIjB,EAAM,IAAMS,EAAKX,MA+BzD,SAASuC,EAAT,KAA8B,IAAD,mBAAfI,EAAe,KAAZC,EAAY,wBAC3B,OAAOD,EADoB,KACZC,EADY,KAI7B,SAASZ,EAAWb,GAClB,MAAqC,IAA7B,EAAIP,KAAKiC,IAAI1B,EAAIP,KAAKkC,KAGhC,SAASR,EAAKS,EAAIC,EAAI7B,GACpB,OAAQ,EAAIA,GAAK4B,EAAK5B,EAAI6B","file":"static/js/0.4546f7c9.chunk.js","sourcesContent":["const GRID = 256; // 纹理划分 256 个格子\nconst GRID_MASK = GRID - 1;\nconst SPEED = [2, 2];\n\nconst template = Array.from({length: GRID * GRID}, (_, k) => {\n  const x = Math.random() * 2 - 1;\n  const y = Math.random() * 2 - 1;\n  return normalizedVector([x, y]);\n});\n\nfunction normalizedVector([x, y]) {\n  const l = Math.sqrt(x * x + y * y);\n  return [\n    x / l,\n    y / l\n  ];\n}\n\nexport default function perlinNoise2D(w, h, t, l) {\n  return Uint8ClampedArray.from({length: w * h}, (_, k) => {\n    const x = ((k % w + t * SPEED[0]) / l) % GRID;\n    const y = ((Math.floor(k / w) + t * SPEED[1]) / l) % GRID;\n    return perlin(x, y);\n  });\n}\n\nfunction perlin(xNoise, yNoise, w, h) {\n  const x0 = xNoise & GRID_MASK;\n  const y0 = yNoise & GRID_MASK;\n\n  const c00 = template[x0 + y0 * GRID];\n  const c01 = template[x0 + (y0 + 1) * GRID];\n  const c10 = template[x0 + 1 + y0 * GRID];\n  const c11 = template[x0 + 1 + (y0 + 1) * GRID];\n\n  const tx = xNoise - x0;\n  const ty = yNoise - y0;\n  const u = smoothstep(tx);\n  const v = smoothstep(ty);\n\n  const p00 = [tx, ty];\n  const p01 = [tx, ty - 1];\n  const p10 = [tx - 1, ty];\n  const p11 = [tx - 1, ty - 1];\n\n  const nx0 = lerp(dot(c00, p00), dot(c10, p10), u);\n  const nx1 = lerp(dot(c01, p01), dot(c11, p11), u);\n\n  const value = lerp(nx0, nx1, v);\n  return (value + 0.5) * 256;\n}\n\nfunction dot([a, b], [c, d]) {\n  return a * c + b * d;\n}\n\nfunction smoothstep(t) {\n  return (1 - Math.cos(t * Math.PI)) * 0.5;\n}\n\nfunction lerp(a0, a1, t) {\n  return (1 - t) * a0 + t * a1;\n}\n"],"sourceRoot":""}